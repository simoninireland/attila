// $Id$

// This file is part of Attila, a retargetable threaded interpreter
// Copyright (c) 2007--2009, Simon Dobson <simon.dobson@computer.org>.
// All rights reserved.
//
// Attila is free software; you can redistribute it and/or
// modify it under the terms of the GNU General Public License
// as published by the Free Software Foundation; either version 2
// of the License, or (at your option) any later version.
//
// Attila is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA.

// Macros etc needed for bootstrapping

#ifndef BOOTSTRAP_H
#define BOOTSTRAP_H

#include "vm.h"

#include <stdio.h>
#include <string.h>
#include <setjmp.h>


// ---------- Debugging ----------

#define DIE( msg ) (printf("FATAL: %s\n", msg), longjmp(env, 0), NULL)


// ---------- Stacks ----------

// Data stack macros
#define PUSH_CELL( cell ) (*(data_stack++)) = ((CELL) cell)
#define POP_CELL() (CELL) ((--data_stack < data_stack_base) ? DIE("data stack underflow") : (*data_stack))
#define DATA_STACK_ITEM( n ) (CELLPTR) (data_stack - (n) - 1) 
#define DATA_STACK_DEPTH() (data_stack - data_stack_base)
#define DATA_STACK_RESET() data_stack = data_stack_base

// Return stack macros
#define PUSH_RETURN( xt ) (*(return_stack++)) = ((XT) xt)
#define POP_RETURN() (XT) ((--return_stack < return_stack_base) ? DIE("return stack underflow") : (*return_stack))
#define PEEK_RETURN() (XT) ((return_stack == return_stack_base) ? DIE("peeking empty return stack") : (*(return_stack - 1)))
#define RETURN_STACK_ITEM( n ) (XTPTR) (return_stack - n - 1) 
#define RETURN_STACK_RESET() return_stack = return_stack_base


// ---------- Compilation helper macros ----------

// User variable offsets
#define USER_COLD 0
#define USER_EXECUTIVE 1
#define USER_CODETOP 2
#define USER_DATATOP 3
#define USER_STATE 4
#define USER_BASE 5
#define USER_INPUTSOURCE 6
#define USER_OUTPUTSINK 7
#define USER__IN 8
#define USER_TIB 9
#define USER_LAST 10
#define USER_TRACE 11
#define USER_CURRENT 12

// Status bitmasks
#define STATUS_IMMEDIATE 1
#define STATUS_REDIRECTABLE 2

// Compiler states
#define STATE_INTERPRETING 0
#define STATE_COMPILING 1

// Primitives as normal words, generated by primgen
extern VOID init_primitives();

extern jmp_buf env;

// The initial dictionary builder
extern VOID init_dictionary();

// The master executive selected on warm-start
extern XT master_executive;

// Some vital interpreter primitives
extern VOID docolon();
extern VOID dovar();

// Helper functions
extern VOID begin_colon_definition( char *name, PRIMITIVE prim, int status );
extern VOID end_colon_definition();
extern VOID compile_cell( CELL c );
extern VOID compile_byte( BYTE b );
extern VOID compile_string( char *str, int len );
extern XT xt_of( char *name );
extern VOID compile_xt_of( char *name );
extern CELLPTR allocate_code_memory( int n );
extern CELLPTR user_variable( int n );

// Definition
#define DEFINE(name) begin_colon_definition(name, &docolon, 0)
#define DEFINE_IMMEDIATE(name) begin_colon_definition(name, &docolon, STATUS_IMMEDIATE)
#define VARIABLE(name) begin_colon_definition(name, &dovar, 0); end_colon_definition()

// Compilation
#define COMPILE_PRIMITIVE(name, prim) begin_colon_definition(name, prim, 0); end_colon_definition()
#define COMPILE(name) compile_xt_of(name)
#define COMPILE_CELL(c) compile_cell(c)
#define LITERAL(val) COMPILE("(LITERAL)"); compile_cell((CELL) val)
#define STRING(str) COMPILE("(SLITERAL)"); compile_string(str, strlen(str))
#define COMPILE_REFERENCE_TO(name) LITERAL(xt_of(name))
#define COMPILE_COMPILE(name) COMPILE_REFERENCE_TO(name); COMPILE("COMPILE,")
#define NEXT() COMPILE_CELL(0); end_colon_definition()
#define COMPILE_NEXT() LITERAL(0);   COMPILE("COMPILE,")

// Data
#define COMPILE_DATA(val) compile_cell(val)
#define COMPILE_DATA_REFERENCE_TO(name) COMPILE_DATA(xt_of(name))

// Control
#define COMPILE_BEGIN(b,u) CELLPTR b = allocate_code_memory(0)
#define COMPILE_UNTIL(b,u) COMPILE("(?BRANCH)");   CELLPTR u = allocate_code_memory(CELL_SIZE);   *u = (CELLPTR) (((BYTE *) b) - ((BYTE *) u))
#define COMPILE_IF(i,t,e) COMPILE("(?BRANCH)"); CELLPTR i = allocate_code_memory(CELL_SIZE)
#define COMPILE_ELSE(i,t,e) COMPILE("(BRANCH)"); CELLPTR e = allocate_code_memory(CELL_SIZE); *i = (CELL) (((BYTE *) e) - ((BYTE *) i) + CELL_SIZE)
#define COMPILE_THEN(i,t,e) CELLPTR t = allocate_code_memory(0); *i = (CELL) (((BYTE *) t) - ((BYTE *) i))
#define COMPILE_ELSETHEN(i,t,e) CELLPTR t = allocate_code_memory(0); *e = (CELL) (((BYTE *) t) - ((BYTE *) e))

// Debugging
#define DEBUG( xt ) show_execute(xt)

#endif
